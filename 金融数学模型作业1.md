# 金融数学模型作业1

**刘权庆 20210180009**

### 一、原题

考虑如下的雪球式结构的收益凭证：

- 标的证券: 中证500指数
- 期限: 12个月
- 敲出水平: 期初价格 × 105%
- 敲入水平: 期初价格 × 75%
- 敲出事件(每月观察) : 若在任一敲出观察日，挂钩标的收盘价格大于敲出水平
- 敲入事件(每日观察) : 若在任一敲入观察日，挂钩标的收盘价格小于敲入水平
- 投资收益
  1. 若敲出，合约自动提前终止, 敲出收益金额: 14% × 名义本金 × 计息天数=365
  2. 未敲入未敲出，合约到期终止,收益金额: 14% × 名义本金 × 计息天数=365
  3. 敲入且未敲出, 合约到期终止,收益金额: (期末价格/期初价格 - 1) × 本金

问题: 假设无风险利率为4.8%，

1. 若中证500指数波动率为20%, 这个收益凭证是否值得买?
2. 波动率在何范围内,这个收益凭证值得买?



### 二、思路与编程实现

##### 1、条件变量的输入

先将题目给定的条件转化为MATLAB中的变量，这里我将进行**Monte Carlo simulation**的轨道数设定为**1,000,000**条，同时假设中证500的**continuous dividend rate**为**0.6%**。

~~~matlab
M=1000000       %轨道数
s0=1000         %期初价格
r=0.14          %给定收益率
mu=0.048        %无风险利率
sigma=0.2       %波动率
d=0.006         %股息率
b_in=0.75       %敲入边界
b_out=1.05      %敲出边界
~~~



##### 2、日期的处理

这里的收益凭证期限为1年，所以我需要获取一个收益凭证的初始日期***StartDate***。

~~~matlab
StartDate=input('初始日期：','s')
~~~

然后将其转换为MATLAB常用的日期变量形式，便于后续的日期区间运算，再计算出期末日期。

~~~matlab
SD=datetime(StartDate,'InputFormat',"yyyyMMdd")

ED=SD+calyears(1)-caldays(1)

EndDate=datestr(ED,'yyyymmdd')
~~~

然后使用wind的MATLAB API接口（需先在命令行调用API）获取期末期初区间内的交易日信息储存在***knockin_date***这个cell数组中，这就是期间内的敲入观察日，将它的size记为***N1***。

~~~matlab
w=windmatlab
~~~

~~~matlab

[knockin_date]=w.tdays(StartDate,EndDate,'Days=Trading')

N1=size(knockin_date,1)
~~~

再利用一个for循环找出一年内的11个敲出观察日储存在***knockout_date***这个cell数组中，size记为***N2***。

~~~matlab
for i = 1:11
    outday=SD+calmonths(i);
    if ismember(outday,knockin_date)
        knockout_date(i,:)={datestr(outday,'yyyy/mm/dd')};
    else
        while ismember(outday,knockin_date)==0
            outday=outday+caldays(1);
        end
        knockout_date(i,:)={datestr(outday,'yyyy/mm/dd')};
    end
end

N2=size(knockout_date,1)
~~~

将日期转化成距凭证起始日期的天数并存入数组***knockin_days***、***knockout_days***。

~~~matlab
knockin_days=datenum(knockin_date);
knockin_days=knockin_days-(datenum(SD)-1)*ones(size(knockin_days));

knockout_days=datenum(knockout_date);
knockout_days=knockout_days-(datenum(SD)-1)*ones(size(knockout_days));
~~~

取出敲出观察日在敲出观察日数组中的位置序号***outindex***。

~~~matlab
sp=1;
for i = 1:N2
    for j = sp:N1
        if knockin_days(j)==knockout_days(i)
            outindex(i)=j;
            sp = j+1;
        end
    end
end
~~~



##### 3、Monte Carlo simulation

为了对**standard brownian motion**进行模拟，我们需要每个观察日之间的时间间隔***wt***（天），它们开根号就是各个观察日间布朗运动正态分布的标准差，将它扩张成每行一致的矩阵***W***。共有1,000,000行，即我们需要的轨道数量。

~~~matlab
wt(1)=knockin_days(1);

for i = 2:N1
    wt(i)=knockin_days(i)-knockin_days(i-1);
end

W=ones(M,1)*sqrt(wt/365)
~~~

接着用**randn**获取我们需要的正态分布随机数，再通过一个非零元素全为1的上三角矩阵将***wt***在每个时点进行累加，得到一个完整的**Brownian Motion**轨道矩阵***T***，进而利用风险中性定价公式获得我们的模拟指数价格过程矩阵***S1***，这是敲入观察日的价格过程，通过***outindex***取出敲出观察日的价格过程矩阵***S2***。

~~~matlab
T=randn(M,N1).*W*triu(ones(N1))

S1=s0*exp((mu-d-sigma.^2/2)*W+sigma*T)

S2=S1(:,outindex)
~~~



##### 4、雪球结构的价值计算

首先要获取每条轨道的敲入敲出数据，可以利用矩阵的逻辑运算得到每个观察日的敲出敲入情况构成矩阵***S_out***、***S_in***，再做矩阵乘法得到每条轨道是否敲出敲入的数据***Path_out***、***Path_in***，最后合并入矩阵***P***：每一行代表一条轨道，第一列数据代表是否敲出，第二列数据代表是否敲入。

~~~matlab
S_out=S2>b_out*s0*ones(size(S2));

Path_out=S_out*ones(N2,1)>zeros(M,1);

S_in=S1<b_in*s0*ones(size(S1));

Path_in=S_in*ones(N1,1)>zeros(M,1);

P=[Path_out Path_in];
~~~

然后就可以对每条轨道的收益凭证现值进行计算：

- 若第一列数据为1，即期间内敲出。则使用find函数找到首次敲出的时间，用给定的收益率计算所得并贴现。
- 若第一列数据为0但第二列为1，即未敲出但敲入。则使用轨道期末价值计算损益并贴现。
- 若两列数据均为0，即未敲入也未敲出。则直接按给定收益率贴现计算收益。

~~~matlab
V=zeros(M,1);

for i = 1:M
    if P(i,1)
        outpoint=knockout_days(find(S_out(i,:),1,'first'));
        fv=1+outpoint/365*r;
        V(i)=fv*exp(-outpoint/365*mu);
    elseif P(i,2)
        V(i)=S1(i,N1)/s0*exp(-knockin_days(N1)/365*mu);
    else
        V(i)=(1+r)*exp(-mu);
    end    
end

V_mean=ones(1,M)*V/M;
~~~

这样得到了每条轨道上模拟的收益凭证价值（用与期初投资的比值表示）向量***V***，随后可以计算出它的平均值***V_mean***。根据**Kolmogorov强大数律**我们知道当样本独立同分布时，样本均值几乎处处收敛于随机变量的期望。我们这里已经有了一百万的样本轨道，也就模拟出了这份收益凭证的期望价值等于***V_mean***[^1]。



##### 5、结论

若***V_mean***大于1则值得购买，小于1则不值得购买。

~~~matlab
StartDate=input('初始日期：','s')

V=MCSE(StartDate,M,s0,r,mu,sigma,d,b_in,b_out);

V

if V > 1
    p=roundn((V-1)*100,-3);
    disp(['该收益凭证价格若不超过本金的',num2str(p),'%则值得购买，反之不值得购买'])
else
    disp('该收益凭证不值得购买')
end
~~~

得到结果如下，说明在**20%**的波动率下若该收益凭证价格不超过本金的**0.238%**，那么就值得购买。

![](D:\Learning\金融数学模型\Assignment1\结果1.png)

最后来考虑第二个问题，我们可以先画出随着波动率变化收益凭证价值变化的图像。

~~~matlab
i=1;
for sigma = 0.1:0.01:0.3
    y(i)=MCSE(StartDate,M,s0,r,mu,sigma,d,b_in,b_out)-1;
    i=i+1;
end

x=0.1:0.01:0.3;

plot(x,y)
axis([0.1 0.3 -0.05 0.05])
~~~

![](D:\Learning\金融数学模型\Assignment1\结果2.png)

可以看出单调趋势，然后我们用二分法来寻找到特定精度的临界值。

~~~matlab
u=0.16;
v=0.24;

while abs(MCSE(StartDate,M,s0,r,mu,(u+v)/2,d,b_in,b_out)-1) > 0.0001
    if MCSE(StartDate,M,s0,r,mu,(u+v)/2,d,b_in,b_out)-1>0
        u=(u+v)/2;
    else
        v=(u+v)/2;
    end
end

threshold=(u+v)/2
~~~

![](D:\Learning\金融数学模型\Assignment1\结果3.png)

以上结果说明当波动率小于**20.38%**时，这种结构的雪球收益凭证值得购买（具有正的价值，具体是否值得要看收益凭证的定价）。

[^1]:以上的程序被我统一写进了函数**MCSE**，输入参数可以得到该种雪球收益凭证的期望价值作为输出。*